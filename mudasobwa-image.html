<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<script src="../exif-js/exif.js"></script>
<!--script src="../caman/dist/caman.full.min.js"></script-->

<polymer-element name="mudasobwa-throbber" attributes="width height color type throbbing">
  <template>
    <div id="container" style="width:{{ w }}px;height:{{ h }}px;display:{{ d }};"></div>
  </template>
  <script>
    Polymer({
      throbber: { value: null, reflect: true },

      computed: {
        w: 'throbber ? width : 0',
        h: 'throbber ? height : 0',
        d: 'throbber ? "block" : "none"'
      },

      /**
      * The `toggleThrobber` method will create a throbber. Used internally by `ready` handler.
      *
      * Code is gratefully stolen from
      *     http://ablog.gawley.org/2009/05/randomness-throbbers-and-tag.html
      *     and adopted for use inside polymer element.
      *
      * @method toggleThrobber
      * @param {Integer} id of the element to embed throbber into.
      */
      throbbingChanged: function() {
        if(!this.throbbing) {
          this.throbber.stop();
          this.throbber = null;
        } else {
          var self = this;
          this.throbber = new function() {
            // prepare canvas
            this.t = self.$.container;
            this.c = document.createElement('canvas');
            this.c.width = parseInt(this.t.style.width); // offsetWidth;
            this.c.height = parseInt(this.t.style.height); // offsetHeight;
            this.t.appendChild(this.c);

            this.options = {
              speedMS: 100,
              center: Math.min(this.c.width, this.c.height) >> 2,
              thickness: Math.min(this.c.width, this.c.height) >> 6,
              spokes: Math.min(this.c.width, this.c.height) >> 3,
              color: self.color,
              style: self.type
            };

            this.throb = function() {
              var ctx = this.c.getContext("2d");
              ctx.translate(this.c.width/2, this.c.height/2);
              var w = Math.floor(Math.min(this.c.width,this.c.height)/2);
              var self = this;
              var o = self.options;
              var draw = function() {
                ctx.clearRect(-self.c.width/2,-self.c.height/2,self.c.width,self.c.height)
                ctx.restore();
                ctx.shadowOffsetX = ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
                ctx.shadowColor = "rgba(220, 220, 220, 0.5)";
                for (var i = 0; i < o.spokes; i++) {
                  r = 255-Math.floor((255-o.color[0]) / o.spokes * i);
                  g = 255-Math.floor((255-o.color[1]) / o.spokes * i);
                  b = 255-Math.floor((255-o.color[2]) / o.spokes * i);
                  ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";

                  if(o.style == "balls") {
                    ctx.beginPath();
                    ctx.moveTo(w,0)
                    ctx.arc(w-Math.floor(Math.PI*2*w/o.spokes/3),0,Math.floor(Math.PI*2*w/o.spokes/3),0,Math.PI*2,true);
                    ctx.fill();
                  } else {
                    ctx.fillRect(o.center, -Math.floor(o.thickness/2), w-o.center, o.thickness);
                  }
                  ctx.rotate(Math.PI/(o.spokes/2));
                  if (i == 0) {
                    ctx.save();
                  }
                }
              };
              draw();
              this.timer = setInterval(draw,this.options.speedMS);
            };

            this.stop = function() {
              clearInterval(this.timer);
              this.c.getContext("2d").clearRect(-this.c.width/2,-this.c.height/2,this.c.width,this.c.height);
              this.t.removeChild(this.c);
            };
          };
          this.throbber.throb();
        }
      }
    });
  </script>
</polymer-element>

<!--
Base element for all the images operations.

##### Example

    <mudasobwa-image src="i/1.jpg"></mudasobwa-image>

@element mudasobwa-image
@blurb Base element for all the image operations.
@status alpha
@homepage http://rocket-science.ru/wc/mudasobwa-image
-->
<polymer-element name="mudasobwa-image" attributes="src">
  <template>
    <link rel="stylesheet" href="mudasobwa-image.css" />

    <core-ajax
      id="imageLoader"
      handleAs="blob"
      on-core-response="{{ gotImage }}"
      on-core-error="{{ failImage }}">
    </core-ajax>

    <mudasobwa-throbber
      id="throbber"
      width="{{ throb.size.width }}"
      height="{{ throb.size.height }}"
      color="{{ throb.color }}"
      type="{{ throb.type }}">
    </mudasobwa-throbber>

    <figure>
      <div id="figure"></div>
      <figcaption id="caption">
        <template if="{{ description }}">
          <p>{{ description }}</p>
        </template>

        <content id="content"></content>
      </figcaption>
    </figure>
  </template>

  <script>

    PolymerExpressions.prototype.elementSize = function(el) {
      var result = { w: 0, h: 0 };
      for (ch in el) {
        result.w += el[ch].offsetWidth;
        result.h += el[ch].offsetHeight;
      }
      return result;
    };

    Polymer({

      src: null,

      canvases: null,
      canvas: { value: null, reflect: true },

      image: null,

      description: { value: null, reflect: true },

      throb: { value: null, reflect: true },

      exif: null,

      publish: { updated: { value: 0, reflect: true } },
      computed: {
        size: 'elementSize($, updated)'
      },

      // ===================================================================
      // ==== internals ====================================================
      // ===================================================================

      // More info: http://www.polymer-project.org/docs/polymer/polymer.html#lifecyclemethods
      created: function() {
        this.throb = {
          type: 'balls',
          color: [0x80,0x80,0x80],
          size: { width: 300, height: 150 }
        };
        this.canvases = [];
      },

      // ===================================================================
      // ==== handlers =====================================================
      // ===================================================================

      srcChanged: function() {
        // pass control to the main thread to avoid lock on image loading
        this.async(function() { this.loadImage(); });
      },

      canvasChanged: function() {
        // FIXME INEFFICTIVE, BLINKING
        this.canvases.forEach(function(c) {
          c.style.display = "none";
        });
        this.canvas.style.display = "";
        if (-1 === this.canvases.indexOf(this.canvas)) {
          this.canvases.push(this.canvas);
        }
      },

      // ===================================================================
      // ==== protected helpers ============================================
      // ===================================================================

      /**
      *  Draws canvas.
      *
      *  http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/
      *
      *      Value	0th Row	0th Column
      *      1	top	left side
      *      2	top	right side
      *      3	bottom	right side
      *      4	bottom	left side
      *      5	left side	top
      *      6	right side	top
      *      7	right side	bottom
      *      8	left side	bottom
      *
      *  @todo currently we do not handle mirroring
      */
      masterpiece: function() {
        if(!this.image) {
          // We are not yet ready to redraw. No worry.
          return false;
        }

        var w = this.image.width;
        var h = this.image.height;
        var a = 0;

        switch (this.orientation) {
          case 3:
            a = Math.PI;
            break;
          case 6:
            w = this.image.height;
            h = this.image.width;
            a = Math.PI / 2.0;
            break;
          case 8:
            w = this.image.height;
            h = this.image.width;
            a = - Math.PI / 2.0;
            break;
        }

        var container = this.$.figure;

        // create canvas
        var canvas = document.createElement('canvas');
        container.style.width = (canvas.width = w) + 'px';
        container.style.height = (canvas.height = h) + 'px';
        this.canvas = canvas;
        container.appendChild(this.canvas);

        // draw image with proper orientation
        var ctx = this.canvas.getContext('2d');
        if (a != 0) {
          ctx.save();
          ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
          ctx.rotate(a);
          ctx.drawImage(this.image, -this.canvas.height / 2, -this.canvas.width / 2);
          ctx.restore();
        } else {
          ctx.drawImage(this.image, 0, 0);
        }

        ctx.save();
        this.updated += 1;
        return ctx;
      },

      draw: function() {
        return this.masterpiece();
      },

      // ===================================================================
      // ==== private helpers ==============================================
      // ===================================================================

      loadImage: function() {
        this.$.imageLoader.url = this.src;
        this.$.throbber.throbbing = true;
        this.$.imageLoader.go();
      },

      gotImage: function() {
        var self = this;

        this.image = new Image();
        this.image.onload = function() {
          EXIF.getData(self.image, function() {
            self.exif = EXIF.getAllTags(self.image);
            self.draw();
            self.fireImageReady();
          });
          self.$.throbber.throbbing = false;
        };
        this.image.src = URL.createObjectURL(this.$.imageLoader.response);
      },

      failImage: function() {
        console.warn("Failed to get requested resource: ", this.src);
        this.$.throbber.throbbing = false;
      },

      getExifTag: function(name) {
        return this.exif ? this.exif[name] : null;
      },

      parseImageDescription: function() {
        this.async(function() {
          // retrieve comment from image
          var comment = this.getExifTag('ImageDescription');

          if (comment && comment.length > 0) { // byte array ⇒ utf8
            var i = 0;
            var c0 = c1 = c2 = c3 = 0;
            var result = '';

            while( i < comment.length ) {
              c0 = comment.charCodeAt(i)&0xff;

              if( c0 < 128 ) {
                result += String.fromCharCode(c0);
                i++;
              } else if( (c0 > 191) && (c0 < 224) ) {
                if( i+1 >= comment.length ) {
                  throw "Bad UTF-8 content in ImageDescription. Skipping...";
                }
                c2 = comment.charCodeAt(i+1)&0xff;
                result += String.fromCharCode( ((c0&31)<<6) | (c2&63) );
                i+=2;
              } else {
                if( i+2 >= comment.length  || i+1 >= comment.length ) {
                  throw "Bad UTF-8 content in ImageDescription. Skipping...";
                }
                c2 = comment.charCodeAt(i+1)&0xff;
                c3 = comment.charCodeAt(i+2)&0xff;
                result += String.fromCharCode( ((c0&15)<<12) | ((c2&63)<<6) | (c3&63) );
                i+=3;
              }
            }

            if (result && result.length > 0) {
              this.fireImageDescription(this.description = result);
            }
          }
        }, this, 10);
      },

      // ===================================================================
      // ==== event fires ==================================================
      // ===================================================================

      fireImageReady: function() {
        this.fire('mudasobwa-image-ready', { image: this.image, exif: this.exif });
        this.parseImageDescription();
      },

      fireImageDescription: function(desc) {
        this.fire('mudasobwa-image-description', { text: desc });
      }

    });

  </script>
</polymer-element>

<polymer-element name="mudasobwa-image-caption" extends="mudasobwa-image"
                 attributes="format caption">
  <script>
    Polymer({
      arabesques: { value: null, reflect: true },

      format: '✎ {caption} ✉ {address} ⌚ {date} ',

      caption: '',

      // ===================================================================
      // ==== overrides ====================================================
      // ===================================================================

      created: function() {
        this.super();
        this.arabesques = {
          font: '12px Impact, fantasy',
          color: 'rgba(255, 255, 255, 0.9)',
          stroke: 'rgba(0, 0, 0, 1)',
          shadow: {
            blur: 7,
            color: 'black'
          },
          lineWidth: 1
        };
      },

      // ===================================================================
      // ==== internals ====================================================
      // ===================================================================

      formatCaption: function() {
        return this.format.replace(/\{[cC]\w*?\}/g, this.caption || '')
                          .replace(/\{[aA]\w*?\}/g, this.address || '')
                          .replace(/\{[gG]\w*?\}/g, this.latlon || '')
                          .replace(/\{[dD]\w*?\}/g, this.date || '')
                          .replace(/\{[tT]\w*?\}/g, this.time || '')
                          .replace(/\{[hH]\w*?\}/g, this.author || '')
                          .replace(/[^\p{S}]  /g, '')
                          .trim();
      },

      draw: function() {
        // the latter replace cleans up empties
        var ctx = this.masterpiece();
        if (!ctx) { // we are not yet ready
          return false;
        }
        var text = this.formatCaption();

        ctx.save();
        // prepare settings for the future
        ctx.font = this.arabesques.font;
        ctx.fillStyle = this.arabesques.color;
        ctx.strokeStyle = this.arabesques.stroke;
        ctx.shadowColor = this.arabesques.shadow.color;
        ctx.shadowBlur = this.arabesques.shadow.blur;
        ctx.lineWidth = this.arabesques.lineWidth;

        ctx.translate(this.canvas.width, this.canvas.height);
        ctx.rotate(- Math.PI / 2);
        ctx.strokeText(text, this.canvas.height - ctx.measureText(text).width - 6, -6);
        ctx.shadowBlur = 0;
        ctx.fillText(text, this.canvas.height - ctx.measureText(text).width - 6, -6);
        ctx.restore();
      },

      // ===================================================================
      // ==== event handlers ===============================================
      // ===================================================================

      captionChanged: function() {
        this.draw();
      }
    });
  </script>
</polymer-element>

<polymer-element name="mudasobwa-image-caman" extends="mudasobwa-image" noscript>
</polymer-element>
