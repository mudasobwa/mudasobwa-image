<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<link rel="import" href="../mudasobwa-nominatim/mudasobwa-nominatim.html">
<script src="../exif-js/exif.js"></script>
<script src="../caman/dist/caman.full.min.js"></script>

<polymer-element name="mudasobwa-throbber" attributes="width height color type throbbing">
  <template>
    <div id="container" style="width:{{ w }}px;height:{{ h }}px;display:{{ d }};"></div>
  </template>
  <script>
    Polymer({
      throbber: { value: null, reflect: true },

      computed: {
        w: 'throbber ? width : 0',
        h: 'throbber ? height : 0',
        d: 'throbber ? "block" : "none"'
      },

      /**
      * The `toggleThrobber` method will create a throbber. Used internally by `ready` handler.
      *
      * Code is gratefully stolen from
      *     http://ablog.gawley.org/2009/05/randomness-throbbers-and-tag.html
      *     and adopted for use inside polymer element.
      *
      * @method toggleThrobber
      * @param {Integer} id of the element to embed throbber into.
      */
      throbbingChanged: function() {
        if(!this.throbbing) {
          this.throbber.stop();
          this.throbber = null;
        } else {
          var self = this;
          this.throbber = new function() {
            // prepare canvas
            this.t = self.$.container;
            this.c = document.createElement('canvas');
            this.c.width = parseInt(this.t.style.width); // offsetWidth;
            this.c.height = parseInt(this.t.style.height); // offsetHeight;
            this.t.appendChild(this.c);

            this.options = {
              speedMS: 100,
              center: Math.min(this.c.width, this.c.height) >> 2,
              thickness: Math.min(this.c.width, this.c.height) >> 6,
              spokes: Math.min(this.c.width, this.c.height) >> 3,
              color: self.color,
              style: self.type
            };

            this.throb = function() {
              var ctx = this.c.getContext("2d");
              ctx.translate(this.c.width/2, this.c.height/2);
              var w = Math.floor(Math.min(this.c.width,this.c.height)/2);
              var self = this;
              var o = self.options;
              var draw = function() {
                ctx.clearRect(-self.c.width/2,-self.c.height/2,self.c.width,self.c.height)
                ctx.restore();
                ctx.shadowOffsetX = ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
                ctx.shadowColor = "rgba(220, 220, 220, 0.5)";
                for (var i = 0; i < o.spokes; i++) {
                  r = 255-Math.floor((255-o.color[0]) / o.spokes * i);
                  g = 255-Math.floor((255-o.color[1]) / o.spokes * i);
                  b = 255-Math.floor((255-o.color[2]) / o.spokes * i);
                  ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";

                  if(o.style == "balls") {
                    ctx.beginPath();
                    ctx.moveTo(w,0)
                    ctx.arc(w-Math.floor(Math.PI*2*w/o.spokes/3),0,Math.floor(Math.PI*2*w/o.spokes/3),0,Math.PI*2,true);
                    ctx.fill();
                  } else {
                    ctx.fillRect(o.center, -Math.floor(o.thickness/2), w-o.center, o.thickness);
                  }
                  ctx.rotate(Math.PI/(o.spokes/2));
                  if (i == 0) {
                    ctx.save();
                  }
                }
              };
              draw();
              this.timer = setInterval(draw,this.options.speedMS);
            };

            this.stop = function() {
              clearInterval(this.timer);
              this.c.getContext("2d").clearRect(-this.c.width/2,-this.c.height/2,this.c.width,this.c.height);
              this.t.removeChild(this.c);
            };
          };
          this.throbber.throb();
        }
      }
    });
  </script>
</polymer-element>

<!--
Base element for all the images operations.

##### Example

    <mudasobwa-image src="i/1.jpg"></mudasobwa-image>

@element mudasobwa-image
@blurb Base element for all the image operations.
@status alpha
@homepage http://rocket-science.ru/wc/mudasobwa-image
-->
<polymer-element name="mudasobwa-image" attributes="src dirty">
  <template>
    <link rel="stylesheet" href="mudasobwa-image.css" />

    <core-ajax
      id="imageLoader"
      handleAs="blob"
      on-core-response="{{ gotImage }}"
      on-core-error="{{ failImage }}">
    </core-ajax>

    <mudasobwa-throbber
      id="throbber"
      width="{{ throb.size.width }}"
      height="{{ throb.size.height }}"
      color="{{ throb.color }}"
      type="{{ throb.type }}">
    </mudasobwa-throbber>

    <figure>
      <div id="figure"></div>
      <figcaption id="caption">
        <template if="{{ description }}">
          <p>{{ description }}</p>
        </template>

        <content id="content"></content>
      </figcaption>
    </figure>
  </template>

  <script>

    PolymerExpressions.prototype.elementSize = function(el) {
      var result = { w: 0, h: 0 };
      for (ch in el) {
        result.w += el[ch].offsetWidth;
        result.h += el[ch].offsetHeight;
      }
      return result;
    };

    Polymer({

      src: null,

      canvases: { value: null, reflect: true },
      canvas: { value: null, reflect: true },

      image: null,

      description: { value: null, reflect: true },

      throb: { value: null, reflect: true },

      exif: null,

      dirty: 0,
      computed: {
        size: 'elementSize($, dirty)'
      },

      // ===================================================================
      // ==== internals ====================================================
      // ===================================================================

      // More info: http://www.polymer-project.org/docs/polymer/polymer.html#lifecyclemethods
      ready: function() {
        this.canvases = [];
        this.throb = {
          type: 'balls',
          color: [0x80,0x80,0x80],
          size: { width: 300, height: 150 }
        };
      },

      // ===================================================================
      // ==== handlers =====================================================
      // ===================================================================

      srcChanged: function() {
        // pass control to the main thread to avoid lock on image loading
        this.async(function() { this.loadImage(); });
      },

      canvasChanged: function() {
        if (-1 === this.canvases.indexOf(this.canvas)) {
          this.canvases.push(this.canvas);
        }
      },

      dirtyChanged: function() {
        this.job('mudasobwa-image-redraw', function() { this.draw(); }, 200);
      },

      // ===================================================================
      // ==== protected helpers ============================================
      // ===================================================================

      /**
      *  Draws canvas.
      *
      *  http://www.daveperrett.com/articles/2012/07/28/exif-orientation-handling-is-a-ghetto/
      *
      *      Value	0th Row	0th Column
      *      1	top	left side
      *      2	top	right side
      *      3	bottom	right side
      *      4	bottom	left side
      *      5	left side	top
      *      6	right side	top
      *      7	right side	bottom
      *      8	left side	bottom
      *
      *  @todo currently we do not handle mirroring
      */
      masterpiece: function() {
        if(!this.image) {
          // We are not yet ready to redraw. No worry.
          return false;
        }

        var w = this.image.width;
        var h = this.image.height;
        var a = 0;

        switch (this.orientation) {
          case 3:
            a = Math.PI;
            break;
          case 6:
            w = this.image.height;
            h = this.image.width;
            a = Math.PI / 2.0;
            break;
          case 8:
            w = this.image.height;
            h = this.image.width;
            a = - Math.PI / 2.0;
            break;
        }

        // create canvas
        this.canvas = document.createElement('canvas');

        var container = this.$.figure;
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
        container.style.width = (this.canvas.width = w) + 'px';
        container.style.height = (this.canvas.height = h) + 'px';
        container.appendChild(this.canvas);

        // draw image with proper orientation
        var ctx = this.canvas.getContext('2d');
        if (a != 0) {
          ctx.save();
          ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
          ctx.rotate(a);
          ctx.drawImage(this.image, -this.canvas.height / 2, -this.canvas.width / 2);
          ctx.restore();
        } else {
          ctx.drawImage(this.image, 0, 0);
        }

        ctx.save();
        return ctx;
      },

      draw: function() {
        return this.masterpiece();
      },

      // ===================================================================
      // ==== private helpers ==============================================
      // ===================================================================

      loadImage: function() {
        this.$.imageLoader.url = this.src;
        this.$.throbber.throbbing = true;
        this.$.imageLoader.go();
      },

      gotImage: function() {
        var self = this;

        this.image = new Image();
        this.image.onload = function() {
          EXIF.getData(self.image, function() {
            self.exif = EXIF.getAllTags(self.image);
            self.dirty += 1;
            self.fireImageReady();
          });
          self.$.throbber.throbbing = false;
        };
        this.image.src = URL.createObjectURL(this.$.imageLoader.response);
      },

      failImage: function() {
        console.warn("Failed to get requested resource: ", this.src);
        this.$.throbber.throbbing = false;
      },

      getExifTag: function(name) {
        return this.exif ? this.exif[name] : null;
      },

      parseImageDescription: function() {
        this.async(function() {
          // retrieve comment from image
          var comment = this.getExifTag('ImageDescription');

          if (comment && comment.length > 0) { // byte array ⇒ utf8
            var i = 0;
            var c0 = c1 = c2 = c3 = 0;
            var result = '';

            while( i < comment.length ) {
              c0 = comment.charCodeAt(i)&0xff;

              if( c0 < 128 ) {
                result += String.fromCharCode(c0);
                i++;
              } else if( (c0 > 191) && (c0 < 224) ) {
                if( i+1 >= comment.length ) {
                  throw "Bad UTF-8 content in ImageDescription. Skipping...";
                }
                c2 = comment.charCodeAt(i+1)&0xff;
                result += String.fromCharCode( ((c0&31)<<6) | (c2&63) );
                i+=2;
              } else {
                if( i+2 >= comment.length  || i+1 >= comment.length ) {
                  throw "Bad UTF-8 content in ImageDescription. Skipping...";
                }
                c2 = comment.charCodeAt(i+1)&0xff;
                c3 = comment.charCodeAt(i+2)&0xff;
                result += String.fromCharCode( ((c0&15)<<12) | ((c2&63)<<6) | (c3&63) );
                i+=3;
              }
            }

            if (result && result.length > 0) {
              this.fireImageDescription(this.description = result);
            }
          }
        }, this, 10);
      },

      // ===================================================================
      // ==== event fires ==================================================
      // ===================================================================

      fireImageReady: function() {
        this.fire('mudasobwa-image-ready', { image: this.image, exif: this.exif });
        this.parseImageDescription();
      },

      fireImageDescription: function(desc) {
        this.fire('mudasobwa-image-description', { text: desc });
      }

    });

  </script>
</polymer-element>

<polymer-element name="mudasobwa-image-caption" extends="mudasobwa-image"
                 attributes="format caption">
  <script>
    Polymer({
      arabesques: { value: null, reflect: true },

      format: '✎ {caption} © {master} ✉ {address} ⌚ {date} ',

      caption: '',

      master: '',

      // ===================================================================
      // ==== overrides ====================================================
      // ===================================================================

      ready: function() {
        this.super();
        this.arabesques = {
          font: '12px Impact, fantasy',
          color: 'rgba(255, 255, 255, 0.9)',
          stroke: 'rgba(0, 0, 0, 1)',
          shadow: {
            blur: 7,
            color: 'black'
          },
          lineWidth: 1
        };
      },

      // ===================================================================
      // ==== internals ====================================================
      // ===================================================================

      formatCaption: function() {
        return this.format.replace(/\{[cC]\w*?\}/g, this.caption || '')
                          .replace(/\{[mM]\w*?\}/g, this.master || '')
                          .replace(/[^\p{S}]  /g, '')
                          .trim();
      },

      draw: function() {
        // the latter replace cleans up empties
        var ctx = this.masterpiece();
        if (!ctx) { // we are not yet ready
          return false;
        }
        var text = this.formatCaption();

        ctx.save();
        // prepare settings for the future
        ctx.font = this.arabesques.font;
        ctx.fillStyle = this.arabesques.color;
        ctx.strokeStyle = this.arabesques.stroke;
        ctx.shadowColor = this.arabesques.shadow.color;
        ctx.shadowBlur = this.arabesques.shadow.blur;
        ctx.lineWidth = this.arabesques.lineWidth;

        ctx.translate(this.canvas.width, this.canvas.height);
        ctx.rotate(- Math.PI / 2);
        ctx.strokeText(text, this.canvas.height - ctx.measureText(text).width - 6, -6);
        ctx.shadowBlur = 0;
        ctx.fillText(text, this.canvas.height - ctx.measureText(text).width - 6, -6);
        ctx.restore();
      },

      // ===================================================================
      // ==== event handlers ===============================================
      // ===================================================================

      captionChanged: function() {
        this.draw();
      }
    });
  </script>
</polymer-element>

<polymer-element name="mudasobwa-image-geo" extends="mudasobwa-image-caption"
                 attributes="exify resolve date time address latlon"
                 on-mudasobwa-image-ready="{{ handleExif }}">
  <template>
    <mudasobwa-nominatim id="nominatim"
      on-mudasobwa-nominatim-response="{{ gotAddress }}">
    </mudasobwa-nominatim>
    <shadow></shadow>
  </template>
  <script>
    Polymer({
      latlon: null,
      gypsy: {},            // internal hash for all geo data formats
      exify: false,
      resolve: false,
      date: null,
      time: null,
      address: null,
      location: null,

      // ===================================================================
      // ==== internals ====================================================
      // ===================================================================

      formatCaption: function() {
        return this.format.replace(/\{[cC]\w*?\}/g, this.caption || '')
                          .replace(/\{[aA]\w*?\}/g, this.address || '')
                          .replace(/\{[gG]\w*?\}/g, this.gypsy.floats || '')
                          .replace(/\{[dD]\w*?\}/g, this.date || '')
                          .replace(/\{[tT]\w*?\}/g, this.time || '')
                          .replace(/\{[mM]\w*?\}/g, this.master || '')
                          .replace(/[^\p{S}]  /g, '')
                          .trim();
      },

      // ===================================================================
      // ==== handlers =====================================================
      // ===================================================================

      // Allows input as [l,l], [[ld,lm,ls],[ld,lm,ls],a], "l,l"
      latlonChanged: function() {
        if (!this.latlon) {
          return;  // no worry
        }

        var result = { lat: {}, lon: {}, alt: null };
        var data = (this.latlon.constructor === String) ?
                    this.latlon.split(/[,;\-\s]+/) : this.latlon;

        if (data.constructor !== Array) {
          console.warn('Bad geo coordinates given. Wrong format, should be Array of String|Array. ');
          throw this.latlon;
        }

        var pretty = /((\d+)°)?((\d+)′)?((\d+)″)?(\w)/;
        var ss = { lat: ['N','S'], lon: ['E', 'W'] };
        ['lat', 'lon'].forEach(function(l, i) {
          switch (data[i].constructor) {
            case Array:
              result[l]['deg'] = data[i][0] || 0;
              result[l]['min'] = data[i][1] || 0;
              result[l]['sec'] = Math.floor(data[i][2] || 0);
              result[l]['semisphere'] = data[i][3] || ss[l][0];
              break;
            case String:
              data[i] = data[i].match(pretty) || +data[i];
            case Number:
              if (data[i].constructor === Array) { // pretty
                result[l]['pretty'] = data[i];
                result[l]['deg'] = data[i][2] || 0;
                result[l]['min'] = data[i][4] || 0;
                result[l]['sec'] = data[i][6] || 0;
                result[l]['semisphere'] = data[i][7] || ss[l][0];
              } else {                             // float
                result[l]['float'] = data[i];
                result[l]['deg'] = Math.floor(data[i]);
                result[l]['min'] = Math.floor((data[i] - result[l]['deg']) * 60);
                result[l]['sec'] = Math.floor(((data[i] - result[l]['deg']) * 60 - result[l]['min']) * 60);
                result[l]['semisphere'] = ss[l][+(+data[i] === -data[i])];
              }
              break;
            default:
              console.warn('Bad geo coordinates given. Wrong format, should be Array of String|Array. ', this.latlon);
              throw this.latlon;
          }
          if (!result[l]['float']) {
            result[l]['float'] = (
              result[l]['deg'] + result[l]['min']/60.0 + result[l]['sec']/3600.0
            ) * (result[l]['semisphere'] === ss[l][0] ? 1 : -1);
          }
          if (result[l]['float'] < -90.0 || result[l]['float'] > 90.0) {
            throw 'Irrelevant geolocation: [' + l + '=' + result[l]['float'] + ']. Geodata is corrupted.';
          };
          if (!result[l]['pretty']) {
            result[l]['pretty'] = '' + result[l]['deg'] + '°'
                                     + result[l]['min'] + '′'
                                     + result[l]['sec'] + '″'
                                     + result[l]['semisphere'];
          }
        });

        // altitude
        if (data.length > 2) {
          result.alt = data[2];
        }
        result.pretty = [result.lat.pretty, result.lon.pretty].join(',');
        result.floats = [result.lat.float, result.lon.float].join(',');
        result.links = {
          osm: 'https://www.openstreetmap.org/#map=18/' + result.lat.float + '/' + result.lon.float,
          google: 'https://www.google.com/maps/place/' + result.lat.pretty + '+' + result.lon.pretty
        }

        this.gypsy = result;
        this.fireGypsy();

        if (this.resolve) {
          this.loadAddress();
        }
      },

      // ===================================================================
      // ==== privats ======================================================
      // ===================================================================

      parseDateTime: function() {
        var timestamp = this.getExifTag('DateTimeOriginal') || this.getExifTag('GPSDateStamp');
        if (timestamp && timestamp.length) {
          var t = timestamp.split(/\s+/);
          var d = t[0].replace(/[:\/.,]/g, '-');
          this.date = d;
          this.time = t[1];
          this.datetime = new Date(d + ' ' + t[1]);
        } else {
          this.date = this.time = this.datetime = null;
        }
      },

      parseGypsy: function() {
        // retrieve geo info from image
        var lat = this.getExifTag('GPSLatitude');
        var lon = this.getExifTag('GPSLongitude');
        var alt = this.getExifTag('GPSAltitude');

        if (lat && lat.constructor === Array && lon && lon.constructor === Array) { // GEO is presented
          lat[3] = this.getExifTag("GPSLatitudeRef");
          lon[3] = this.getExifTag("GPSLongitudeRef");
          this.latlon = [lat, lon, ('1' == this.getExifTag("GPSAltitudeRef")) ? -alt : +alt];
        }
      },

      handleExif: function(e) {
        if (this.exify) {
          this.parseDateTime();
          this.parseGypsy();
          this.dirty += 1;
        }
      },

      loadAddress: function() {
        if (this.gypsy) {
          this.$.nominatim.latitude = this.gypsy.lat.float;
          this.$.nominatim.longitude = this.gypsy.lon.float;
          this.$.nominatim.go();
        }
      },

      gotAddress: function(e) {
        this.address = e.detail.address;
        this.location = e.detail.response;
        this.fireLocation();
        this.dirty += 1;
      },

      // ===================================================================
      // ==== event fires ==================================================
      // ===================================================================

      fireGypsy: function() {
        this.fire('mudasobwa-image-gypsy', { gypsy: this.gypsy });
      },

      fireLocation: function() {
        this.fire('mudasobwa-image-location', { location: this.location, display: this.address });
      }

    });
    </script>
</polymer-element>

<polymer-element name="mudasobwa-image-caman" extends="mudasobwa-image-geo"
                 attributes="brightness channels clip colorize contrast
                             exposure gamma greyscale hue invert noise
                             saturation sepia vibrance">
  <script>
    Polymer({
      brightness: 0,
      channels: null,
      clip: 100,
      colorize: null,
      contrast: 0,
      // FIXME curves
      exposure: 0,
      // FIXME fillColor: null,
      gamma: 1,
      greyscale: false,
      hue: 0,
      invert: false,
      noise: 0,
      saturation: 0,
      sepia: 0,
      vibrance: 0,

      camanify: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }

        var self = this;
        Caman(this.canvas, function() {
          if (self.brightness) this.brightness(self.brightness);
          if (self.channels) this.channels(self.channels);
          if (self.clip != 100) this.clip(self.clip);
          if (self.colorize) this.colorize(self.colorize);
          if (self.contrast) this.contrast(self.contrast);
          if (self.exposure) this.exposure(self.exposure);
          if (self.gamma !== 1) this.gamma(self.gamma);
          if (self.hue) this.hue(self.hue);
          if (self.noise) this.noise(self.noise);
          if (self.sepia) this.sepia(self.sepia);
          if (self.saturation) this.saturation(self.saturation);
          if (self.vibrance) this.vibrance(self.vibrance);
          if (self.greyscale) this.greyscale();
          if (self.invert) this.invert();

          this.render();
        });
      },

      ready: function() {
        this.super();
        /*
        this.channels = { red: 0, green: 0, blue: 0 };
        this.colorize = { red: 0, green: 0, blue: 0, strength: 0 };
        this.fillColor = { red: 0, green: 0, blue: 0 };
        */
      },

      canvasChanged: function() {
        this.super();
        this.camanify();
      },

      brightnessChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.brightness(self.brightness).render(); });
      },

      channelsChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        if(this.channels) {
          var self = this;
          Caman(this.canvas, function () { this.channels(self.channels).render(); });
        }
      },

      clipChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.clip(self.clip).render(); });
      },

      colorizeChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        if(this.colorize) {
          var self = this;
          Caman(this.canvas, function () { this.colorize(self.colorize).render(); });
        }
      },

      contrastChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.contrast(self.contrast).render(); });
      },

      exposureChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.exposure(self.exposure).render(); });
      },

      gammaChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.gamma(self.gamma).render(); });
      },

      greyscaleChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        if (this.greyscale) {
          Caman(this.canvas, function () { this.greyscale().render(); });
        }
      },

      hueChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.hue(self.hue).render(); });
      },

      invertChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        if (this.greyscale) {
          Caman(this.canvas, function () { this.invert().render(); });
        }
      },

      noiseChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.noise(self.noise).render(); });
      },

      saturationChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.saturation(self.saturation).render(); });
      },

      sepiaChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.sepia(self.sepia).render(); });
      },

      vibranceChanged: function() {
        if (!this.canvas || this.canvas.constructor !== HTMLCanvasElement) { return; }
        var self = this;
        Caman(this.canvas, function () { this.vibrance(self.vibrance).render(); });
      }
    });
  </script>
</polymer-element>
